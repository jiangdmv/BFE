# 1. What are the time and space complexity for sorting algorithms

### Problem

https://bigfrontend.dev/question/what-are-the-time-and-space-complexity-for-main-sorting-algorithms

#

### Problem Description

FrontEnd engineer interviews are usually not about difficult algorithm problems. Yet still it is a must to comprehend the cost of common sorting algorithms.

First you should remember how many sorting algorithms are there, and how they work.

Then you should answer the average time/space complexity for each, and also the worst case for each.

Don't forget to mention the stability.

#

### Solution

| ALGORITHM   | AVERAGE TIME COMPLEXITY | BEST TIME COMPLEXITY | WORST TIME COMPLEXITY | SPACE COMPLEXITY     |
| ----------- | ----------------------- | -------------------- | --------------------- | -------------------- |
| Merge Sort  | O(n\*log(n))            | O(n\*log(n))         | O(n\*log(n))          | Depends O(n\*log(n)) |
| Quicksort   | O(n\*log(n))            | O(n\*log(n))         | O(n^2)                | O(n)                 |
| Heap Sort   | O(n\*log(n))            | O(n\*log(n))         | O(n\*log(n))          | O(n)                 |
| Bubble sort | O(n^2)                  | O(n^2)               | O(n^2)                | O(n)                 |

1. Merge Sort n\*log(n) stable

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function (nums) {
  if (nums.length < 2) {
    return nums;
  }
  const left = sortArray(nums.slice(0, parseInt(nums.length / 2))),
    right = sortArray(nums.slice(parseInt(nums.length / 2))),
    merged = [];
  let i = 0,
    j = 0;
  while (i < left.length && j < right.length) {
    merged.push(left[i] > right[j] ? right[j++] : left[i++]);
  }
  return merged.concat(left.slice(i), right.slice(j));
};
```

2. Quick Sort n\*log(n) unstable

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function (nums) {
  if (nums.length <= 1) return nums;
  const pivot = nums.pop();
  const less = sortArray(nums.filter((n) => n <= pivot));
  const more = sortArray(nums.filter((n) => n > pivot));
  return less.concat(pivot, more);
};
```

2. Heap Sort n\*log(n)

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function (nums) {
  const mid = Math.floor(nums.length / 2);

  for (let i = mid; i >= 0; i--) {
    trickleDown(i, nums.length);
  }

  for (let i = nums.length - 1; i >= 0; i--) {
    swap(0, i);
    trickleDown(0, i);
  }

  function swap(i, j) {
    [nums[i], nums[j]] = [nums[j], nums[i]];
  }

  function trickleDown(idx, boundary) {
    let max = idx;
    let left = idx * 2 + 1;
    let right = idx * 2 + 2;

    if (left < boundary && nums[left] > nums[max]) max = left;
    if (right < boundary && nums[right] > nums[max]) max = right;

    if (max !== idx) {
      swap(max, idx);
      trickleDown(max, boundary);
    }
  }
  return nums;
};
```
